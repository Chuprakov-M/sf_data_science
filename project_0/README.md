## Оглавление  
[1. Описание проекта](README.md#Описание-проекта)  
[2. Какой кейс решаем?](README.md#Какой-кейс-решаем)  
[3. Краткая информация о данных](README.md#Краткая-информация-о-данных)  
[4. Алгоритм отгадывания](README.md#Алгоритм-отгадывания)  
[5. Результат](README.md#Результат)    
[6. Выводы](README.md#Выводы) 

### Описание проекта    
Угадать загаданное компьютером число за минимальное число попыток.
my_game.py - файл игры, содержит необходимые библиотеки и может запускаться самостоятельно
start_game.ipynb и start_game.py - "красивые" файлы запуска игры с импортом необходимых библиотек

:arrow_up:[к оглавлению](README.md#Оглавление)


### Какой кейс решаем?    
Нужно написать программу, которая угадывает число за минимальное число попыток

**Условия соревнования:**  
- Компьютер загадывает целое число от 0 до 100, и нам его нужно угадать. Под «угадать», подразумевается «написать программу, которая угадывает число».
- Алгоритм учитывает информацию о том, больше ли случайное число или меньше нужного нам.

**Метрика качества**     
Результаты оцениваются по среднему количеству попыток при 1000 повторений

**Что практикуем**     
Учимся писать хороший код на python


### Краткая информация о данных
Задается число от 1 до 100, его и отгадываем
  
:arrow_up:[к оглавлению](README.md#Оглавление)


### Алгоритм отгадывания
Используем деление множества вариантов пополам или близко к пополам, тем самым уменьшая поле перебора вдвое
1. Назовем в качестве отгадки число равное среднему между минимально возоможным (1) и максимально возможным + 1 (101), округленному вниз (целочисленное деление)
2. Если загаданное число больше нашей отгадки, то увеличиваем минимально возможное число до нашей отгадки и повторяем алгортим из п. 1
3. Если загаданное число меньше нашей отгадки, то уменьшаем максимально возможное число до нашей отгадки и повторяем алгортим из п. 1

Пример: число 9.
(1+101)//2=50 - меньше -> (1+50)//2=25 - меньше -> (1+25)//2=13 - меньше, (1+13)//2=7 - больше -> (8+13)//2=10 - меньше -> (8+10)//2=9 - отгадали за 6 раз.

101 в качестве верхней границы вместо 100 нужно брать, т.к. иначе при последовательности нижней границы (а только она и будет расти) получим ряд: 50 - 75 - 87 - 93 - 96 - 98 - 99. А так как (99+100)//2=99, то так мы уйдем в бесконечный цикл

:arrow_up:[к оглавлению](README.md#Оглавление)


### Результаты:  
Если брать не согласно очень странному условию случайные 1000 чисел, а просто взять 1, 2, 3 и т.д. до 100, то среднее число попыток равно 5.8, а максимальное - 8 (как раз при отгадывании 100). Более того, так как 2 в степени 7 равно 128, то любое число от 1 до 128 можно угадать не более чем за 7 раз, кроме 128 - его мы отгадаем только на 8ой попытке.
Этот эффект получается из-за того, что мы за 1 раз называем одно число, которое делит множество вариантов на 2. Далее мы в зависимости от результатов попытки попадаем в одно из этих множеств и можем выбрать по 1 числу в каждом из них. После каждой попытки количество чисел, в которые мы можем попасть, удваивается, а 1+2+4+8+16+32+64=127, что меньше 128, и 7 попыток не хватит. Т.е. мы делим множество вариантов не на 2 равных, а на 2 почти равных, что и дает погрешность на 1 попытку вверх. Если бы мы могли спрашивать вопросы в стиле "n-ый двоичный разряд загаданного числаравен 0?", то за 7 вопросов мы бы восстановили двоичное представление любого числа (правда, не от 1 до 128, а от 0 до 127 - но тогдв вопрос модифицировать можно: n-ый двоичный разряд загаданного числа + 1 равен 0?

:arrow_up:[к оглавлению](README.md#Оглавление)


### Выводы:  
baseline = 20 - слишком много

:arrow_up:[к оглавлению](README.md#Оглавление)